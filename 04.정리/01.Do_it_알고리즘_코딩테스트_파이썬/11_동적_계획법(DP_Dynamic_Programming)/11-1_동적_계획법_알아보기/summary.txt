동적 계획법(DP : Dynamic Programming)
- 복잡한 문제를 여러 개의 간단한 문제로 분리하여 부분의 문제를 해결함으로써 최종적으로 복잡한 문제의 답을 구하는 방법
- 원리와 구현 방식
    1. 큰 문제를 작은 문제로 나눌 수 있어야 한다.
    2. 작은 문제들이 반복돼 나타나고 사용되며 이 작은 문제들의 결괏값은 항상 같아야 한다.
    3. 모든 작은 문제들은 한 번만 계산해 DP 테이블에 저장하며 추후 재사용할 때 이 DP 테이블을 이용한다. 이를 메모이이제이션(memoization) 기법이라고 한다.
    4. 동적 계획법은 톱-다운 방식(top-down)과 바텀-업 방식(bottom-up)으로 구현할 수 있다.

[예시] 피보나치 수열
1. 공식
    D[N] = D[N-1] + D[N-2]  # N번째 수열 = N - 1번째 수열 + N - 2번째 수열
2. 동적 계획법으로 풀 수 있는지 확인
    6번째 피보나치 수열은 5번재 피보나치 수열과 4번째 피보나치 수열의 합이다. 즉, 6번째 피보나치 수열을 구하는 문제는 5번째 피보나치 수열과 4번째 피보나치 수열을 구하는 작은 문제로
    나눌 수 있고, 수열의 값은 항상 같기 때문에 동적 계획법으로 풀 수 있다.
3. 점화식 세우기
    점화식을 세울 때는 논리적으로 전체 문제를 나누고, 전체 문제와 부분 문제 간의 인과 관계를 파악해야 한다.
    이 예제는 피보나치 수열 공식 자체가 점화식이므로 D[i] = D[i-1] + D[i-2]가 점화식이다.
4. 메모이제이션 원리 이해하기
    메모이제이션 이란? 부분 문제를 풀었을 때 이 문제를 DP 테이블에 저장해 놓고 다음에 같은 문제가 나왔을 때 재계산하지 않고 DP 테이블의 값을 이용하는 것
5. 톱-다운 구현 방식 이해하기
    위에서부터 문제를 파악해 내려오는 방식
    재귀 함수 형태로 코드 구현
    코드의 가독성이 좋고 이해하기 편하다

[파이썬 코드]
import sys
input = sys.stdin.readline
N = int(input())
D = [-1]*(N+1)
D[0] = 0
D[1] = 1

def fibo(n) :
    if D[n] != -1 :
        return D[n]
    D[n] = fibo(n - 2) + fibo(n - 1)
    return D[n]

fibo(N)
print(D[N])

6. 바텀-업 구현 방식 이해하기
    가장 작은 부분 문제부터 해결하면서 점점 큰 문제로 확장하는 방식
    주로 반복문 형태로 구현

[파이썬 코드]
import sys
input = sys.stdin.readline
N = int(input())
D = [-1]*(N+1)
D[0] = 0
D[1] = 1

for i in range(2, N+1) :
    D[i] = D[i - 2] + D[i - 1]

print(D[N])